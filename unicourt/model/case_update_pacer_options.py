# coding: utf-8

"""
    UniCourt Enterprise APIs

    <button><a href=\"/developers/enterpriseapi/api/download/UniCourt-Enterprise-API-Spec.yaml\" >Download UniCourt Enterprise APIs Specification</a></button> 

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from unicourt.model.case_update_pacer_options_additional_page_array_inner import CaseUpdatePacerOptionsAdditionalPageArrayInner
from typing import Optional, Set
from typing_extensions import Self

class CaseUpdatePacerOptions(BaseModel):
    """
    Applicable for PACER cases.
    """ # noqa: E501
    pacer_user_id: Annotated[str, Field(min_length=6, strict=True, max_length=40)] = Field(description="**Your PACER credentials username. This is mandatory when a PACER Case is being requested in the API. For Non PACER cases this is not mandatory. Suppose your request consists of Non PACER and PACER Cases then this needs to be passed becuase you are requesting a PACER case too.**", alias="pacerUserId")
    pacer_client_code: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=32)]] = Field(default=None, description="This is mandatory if your setting in PACER website is set to Yes for the flag `Require Client Code?` under `Set PACER Billing Preferences` page. The client code is a text field entered by users upon login that can be used to track usage by person, client matter number, or other meaningful entry up to 32 characters, comprising the following:    Alphabetic characters (A-Z or a-z)    Numeric digits (0-9)   Period (.)    Underscore (_)    Hyphen (-)    Slash (/)", alias="pacerClientCode")
    fetch_participants_if_older_than_days: Optional[Annotated[int, Field(le=100, strict=True, ge=0)]] = Field(default=0, description="**You can now limit the frequency at which parties and attorneys for a PACER case are fetched, helping to reduce PACER fees. If you track cases daily or hourly, you could accrue a large PACER bill.**  **Currently, this option applies only to Federal PACER cases and is not available for bankruptcy and appeal cases within Federal PACER. For these case types, participants (parties and counsel) are fetched by default, and there is no option to exclude them.**  **Use Case: Cases are typically updated to check for new docket entry filings. However every update to the PACER case costs money. Participants for a case change less often than docket entry filings. So fetching participants for every update might result in unnecessary PACER costs; especially in cases which have a lot of parties and attorneys. So instead of getting charged the minimum cost of $0.10 for an update which might have had few docket entries, you could end up spending $3 for every update because there were a lot of parties for that case that were also fetched.**  **With this option you can choose when to fetch parties for cases based on when it was last fetched.** You can limit how often these participants are fetched in a PACER case to keep your PACER costs under control.  Min days is 0  and Max days is 100.  Example: 1.  Specifying a value of 0 ensures that participants are fetched from PACER for this case update irrespective of when the participants were last fetched. 2.  Specifying a value of 30 ensures that participants are fetched from PACER for this case update only if the last fetch was older than 30 days. ", alias="fetchParticipantsIfOlderThanDays")
    refresh_type: Optional[Annotated[str, Field(min_length=21, strict=True, max_length=21)]] = Field(default='fetchNewDocketEntries', description="This flag determines whether to pull only new or pull all the docket entries for a PACER case being requested.  Only one of the two values is allowed: -   fetchNewDocketEntries:     >   Updates the PACER case with only new docket entries that have been added after the previous update of the case being requested. -   fetchAllDocketEntries:     >   Updates the PACER case by re-parsing all dockets from #1 till latest docket entry available. ", alias="refreshType")
    additional_page_array: Optional[List[CaseUpdatePacerOptionsAdditionalPageArrayInner]] = Field(default=None, description="Currently this option is only applicable for Federal PACER cases. The default behavior of the Case Update is to fetch the Docket Report from PACER which includes the parties and attorneys too.  However if you need to fetch information for other pages in PACER you will need to specify it here. - associatedCases: > This will fetch the Associated Cases page in PACER if available. This page consists of related cases especially applicable for Multi-District Litigation cases and Member Cases. Including this option will internally link all related cases in our system. Data from this page will be available via the Related Cases API. - caseSummary: > This will fetch the Case Summary page in PACER if available. This page consists of additional case info which is not present in the Docket Report page. Data from this page will be structured and available as response in the Case API’s ```additional_info``` field. - listOfCreditors: > This page will fetch the “List Of Creditors” page for PACER Bankruptcy cases of case type \"bk\". Note that this page cannot be extracted for Bankruptcy cases of case type \"ap\" (Adversary Proceedings). This page consists of the Creditor information like the name and address of the Creditors. Data from this page will be structured and available as response in the Case API. ", alias="additionalPageArray")
    __properties: ClassVar[List[str]] = ["pacerUserId", "pacerClientCode", "fetchParticipantsIfOlderThanDays", "refreshType", "additionalPageArray"]

    @field_validator('pacer_client_code')
    def pacer_client_code_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[a-zA-Z0-9._\-\/]+$", value):
            raise ValueError(r"must validate the regular expression /^[a-zA-Z0-9._\-\/]+$/")
        return value

    @field_validator('refresh_type')
    def refresh_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['fetchNewDocketEntries', 'fetchAllDocketEntries']):
            raise ValueError("must be one of enum values ('fetchNewDocketEntries', 'fetchAllDocketEntries')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CaseUpdatePacerOptions from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in additional_page_array (list)
        _items = []
        if self.additional_page_array:
            for _item in self.additional_page_array:
                if _item:
                    _items.append(_item.to_dict())
            _dict['additionalPageArray'] = _items
        # set to None if pacer_client_code (nullable) is None
        # and model_fields_set contains the field
        if self.pacer_client_code is None and "pacer_client_code" in self.model_fields_set:
            _dict['pacerClientCode'] = None

        # set to None if refresh_type (nullable) is None
        # and model_fields_set contains the field
        if self.refresh_type is None and "refresh_type" in self.model_fields_set:
            _dict['refreshType'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CaseUpdatePacerOptions from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "pacerUserId": obj.get("pacerUserId"),
            "pacerClientCode": obj.get("pacerClientCode"),
            "fetchParticipantsIfOlderThanDays": obj.get("fetchParticipantsIfOlderThanDays") if obj.get("fetchParticipantsIfOlderThanDays") is not None else 0,
            "refreshType": obj.get("refreshType") if obj.get("refreshType") is not None else 'fetchNewDocketEntries',
            "additionalPageArray": [CaseUpdatePacerOptionsAdditionalPageArrayInner.from_dict(_item) for _item in obj["additionalPageArray"]] if obj.get("additionalPageArray") is not None else None
        })
        return _obj


